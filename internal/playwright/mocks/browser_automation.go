// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"
	"time"

	"github.com/inference-gateway/playwright-agent/internal/playwright"
)

type FakeBrowserAutomation struct {
	ClickElementStub        func(context.Context, string, string, map[string]any) error
	clickElementMutex       sync.RWMutex
	clickElementArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 map[string]any
	}
	clickElementReturns struct {
		result1 error
	}
	clickElementReturnsOnCall map[int]struct {
		result1 error
	}
	CloseBrowserStub        func(context.Context, string) error
	closeBrowserMutex       sync.RWMutex
	closeBrowserArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	closeBrowserReturns struct {
		result1 error
	}
	closeBrowserReturnsOnCall map[int]struct {
		result1 error
	}
	ExecuteScriptStub        func(context.Context, string, string, []any) (any, error)
	executeScriptMutex       sync.RWMutex
	executeScriptArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []any
	}
	executeScriptReturns struct {
		result1 any
		result2 error
	}
	executeScriptReturnsOnCall map[int]struct {
		result1 any
		result2 error
	}
	ExtractDataStub        func(context.Context, string, []map[string]any, string) (string, error)
	extractDataMutex       sync.RWMutex
	extractDataArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []map[string]any
		arg4 string
	}
	extractDataReturns struct {
		result1 string
		result2 error
	}
	extractDataReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	FillFormStub        func(context.Context, string, []map[string]any, bool, string) error
	fillFormMutex       sync.RWMutex
	fillFormArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []map[string]any
		arg4 bool
		arg5 string
	}
	fillFormReturns struct {
		result1 error
	}
	fillFormReturnsOnCall map[int]struct {
		result1 error
	}
	GetHealthStub        func(context.Context) error
	getHealthMutex       sync.RWMutex
	getHealthArgsForCall []struct {
		arg1 context.Context
	}
	getHealthReturns struct {
		result1 error
	}
	getHealthReturnsOnCall map[int]struct {
		result1 error
	}
	GetSessionStub        func(string) (*playwright.BrowserSession, error)
	getSessionMutex       sync.RWMutex
	getSessionArgsForCall []struct {
		arg1 string
	}
	getSessionReturns struct {
		result1 *playwright.BrowserSession
		result2 error
	}
	getSessionReturnsOnCall map[int]struct {
		result1 *playwright.BrowserSession
		result2 error
	}
	HandleAuthenticationStub        func(context.Context, string, string, string, string, string, map[string]string) error
	handleAuthenticationMutex       sync.RWMutex
	handleAuthenticationArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 map[string]string
	}
	handleAuthenticationReturns struct {
		result1 error
	}
	handleAuthenticationReturnsOnCall map[int]struct {
		result1 error
	}
	LaunchBrowserStub        func(context.Context, *playwright.BrowserConfig) (*playwright.BrowserSession, error)
	launchBrowserMutex       sync.RWMutex
	launchBrowserArgsForCall []struct {
		arg1 context.Context
		arg2 *playwright.BrowserConfig
	}
	launchBrowserReturns struct {
		result1 *playwright.BrowserSession
		result2 error
	}
	launchBrowserReturnsOnCall map[int]struct {
		result1 *playwright.BrowserSession
		result2 error
	}
	NavigateToURLStub        func(context.Context, string, string, string, time.Duration) error
	navigateToURLMutex       sync.RWMutex
	navigateToURLArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 time.Duration
	}
	navigateToURLReturns struct {
		result1 error
	}
	navigateToURLReturnsOnCall map[int]struct {
		result1 error
	}
	ShutdownStub        func(context.Context) error
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct {
		arg1 context.Context
	}
	shutdownReturns struct {
		result1 error
	}
	shutdownReturnsOnCall map[int]struct {
		result1 error
	}
	TakeScreenshotStub        func(context.Context, string, string, bool, string, string, int) error
	takeScreenshotMutex       sync.RWMutex
	takeScreenshotArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 bool
		arg5 string
		arg6 string
		arg7 int
	}
	takeScreenshotReturns struct {
		result1 error
	}
	takeScreenshotReturnsOnCall map[int]struct {
		result1 error
	}
	WaitForConditionStub        func(context.Context, string, string, string, string, time.Duration, string) error
	waitForConditionMutex       sync.RWMutex
	waitForConditionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 time.Duration
		arg7 string
	}
	waitForConditionReturns struct {
		result1 error
	}
	waitForConditionReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]any
	invocationsMutex sync.RWMutex
}

func (fake *FakeBrowserAutomation) ClickElement(arg1 context.Context, arg2 string, arg3 string, arg4 map[string]any) error {
	fake.clickElementMutex.Lock()
	ret, specificReturn := fake.clickElementReturnsOnCall[len(fake.clickElementArgsForCall)]
	fake.clickElementArgsForCall = append(fake.clickElementArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 map[string]any
	}{arg1, arg2, arg3, arg4})
	stub := fake.ClickElementStub
	fakeReturns := fake.clickElementReturns
	fake.recordInvocation("ClickElement", []any{arg1, arg2, arg3, arg4})
	fake.clickElementMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBrowserAutomation) ClickElementCallCount() int {
	fake.clickElementMutex.RLock()
	defer fake.clickElementMutex.RUnlock()
	return len(fake.clickElementArgsForCall)
}

func (fake *FakeBrowserAutomation) ClickElementCalls(stub func(context.Context, string, string, map[string]any) error) {
	fake.clickElementMutex.Lock()
	defer fake.clickElementMutex.Unlock()
	fake.ClickElementStub = stub
}

func (fake *FakeBrowserAutomation) ClickElementArgsForCall(i int) (context.Context, string, string, map[string]any) {
	fake.clickElementMutex.RLock()
	defer fake.clickElementMutex.RUnlock()
	argsForCall := fake.clickElementArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeBrowserAutomation) ClickElementReturns(result1 error) {
	fake.clickElementMutex.Lock()
	defer fake.clickElementMutex.Unlock()
	fake.ClickElementStub = nil
	fake.clickElementReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) ClickElementReturnsOnCall(i int, result1 error) {
	fake.clickElementMutex.Lock()
	defer fake.clickElementMutex.Unlock()
	fake.ClickElementStub = nil
	if fake.clickElementReturnsOnCall == nil {
		fake.clickElementReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clickElementReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) CloseBrowser(arg1 context.Context, arg2 string) error {
	fake.closeBrowserMutex.Lock()
	ret, specificReturn := fake.closeBrowserReturnsOnCall[len(fake.closeBrowserArgsForCall)]
	fake.closeBrowserArgsForCall = append(fake.closeBrowserArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.CloseBrowserStub
	fakeReturns := fake.closeBrowserReturns
	fake.recordInvocation("CloseBrowser", []any{arg1, arg2})
	fake.closeBrowserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBrowserAutomation) CloseBrowserCallCount() int {
	fake.closeBrowserMutex.RLock()
	defer fake.closeBrowserMutex.RUnlock()
	return len(fake.closeBrowserArgsForCall)
}

func (fake *FakeBrowserAutomation) CloseBrowserCalls(stub func(context.Context, string) error) {
	fake.closeBrowserMutex.Lock()
	defer fake.closeBrowserMutex.Unlock()
	fake.CloseBrowserStub = stub
}

func (fake *FakeBrowserAutomation) CloseBrowserArgsForCall(i int) (context.Context, string) {
	fake.closeBrowserMutex.RLock()
	defer fake.closeBrowserMutex.RUnlock()
	argsForCall := fake.closeBrowserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBrowserAutomation) CloseBrowserReturns(result1 error) {
	fake.closeBrowserMutex.Lock()
	defer fake.closeBrowserMutex.Unlock()
	fake.CloseBrowserStub = nil
	fake.closeBrowserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) CloseBrowserReturnsOnCall(i int, result1 error) {
	fake.closeBrowserMutex.Lock()
	defer fake.closeBrowserMutex.Unlock()
	fake.CloseBrowserStub = nil
	if fake.closeBrowserReturnsOnCall == nil {
		fake.closeBrowserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeBrowserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) ExecuteScript(arg1 context.Context, arg2 string, arg3 string, arg4 []any) (any, error) {
	var arg4Copy []any
	if arg4 != nil {
		arg4Copy = make([]any, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.executeScriptMutex.Lock()
	ret, specificReturn := fake.executeScriptReturnsOnCall[len(fake.executeScriptArgsForCall)]
	fake.executeScriptArgsForCall = append(fake.executeScriptArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 []any
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.ExecuteScriptStub
	fakeReturns := fake.executeScriptReturns
	fake.recordInvocation("ExecuteScript", []any{arg1, arg2, arg3, arg4Copy})
	fake.executeScriptMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBrowserAutomation) ExecuteScriptCallCount() int {
	fake.executeScriptMutex.RLock()
	defer fake.executeScriptMutex.RUnlock()
	return len(fake.executeScriptArgsForCall)
}

func (fake *FakeBrowserAutomation) ExecuteScriptCalls(stub func(context.Context, string, string, []any) (any, error)) {
	fake.executeScriptMutex.Lock()
	defer fake.executeScriptMutex.Unlock()
	fake.ExecuteScriptStub = stub
}

func (fake *FakeBrowserAutomation) ExecuteScriptArgsForCall(i int) (context.Context, string, string, []any) {
	fake.executeScriptMutex.RLock()
	defer fake.executeScriptMutex.RUnlock()
	argsForCall := fake.executeScriptArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeBrowserAutomation) ExecuteScriptReturns(result1 any, result2 error) {
	fake.executeScriptMutex.Lock()
	defer fake.executeScriptMutex.Unlock()
	fake.ExecuteScriptStub = nil
	fake.executeScriptReturns = struct {
		result1 any
		result2 error
	}{result1, result2}
}

func (fake *FakeBrowserAutomation) ExecuteScriptReturnsOnCall(i int, result1 any, result2 error) {
	fake.executeScriptMutex.Lock()
	defer fake.executeScriptMutex.Unlock()
	fake.ExecuteScriptStub = nil
	if fake.executeScriptReturnsOnCall == nil {
		fake.executeScriptReturnsOnCall = make(map[int]struct {
			result1 any
			result2 error
		})
	}
	fake.executeScriptReturnsOnCall[i] = struct {
		result1 any
		result2 error
	}{result1, result2}
}

func (fake *FakeBrowserAutomation) ExtractData(arg1 context.Context, arg2 string, arg3 []map[string]any, arg4 string) (string, error) {
	var arg3Copy []map[string]any
	if arg3 != nil {
		arg3Copy = make([]map[string]any, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.extractDataMutex.Lock()
	ret, specificReturn := fake.extractDataReturnsOnCall[len(fake.extractDataArgsForCall)]
	fake.extractDataArgsForCall = append(fake.extractDataArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []map[string]any
		arg4 string
	}{arg1, arg2, arg3Copy, arg4})
	stub := fake.ExtractDataStub
	fakeReturns := fake.extractDataReturns
	fake.recordInvocation("ExtractData", []any{arg1, arg2, arg3Copy, arg4})
	fake.extractDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBrowserAutomation) ExtractDataCallCount() int {
	fake.extractDataMutex.RLock()
	defer fake.extractDataMutex.RUnlock()
	return len(fake.extractDataArgsForCall)
}

func (fake *FakeBrowserAutomation) ExtractDataCalls(stub func(context.Context, string, []map[string]any, string) (string, error)) {
	fake.extractDataMutex.Lock()
	defer fake.extractDataMutex.Unlock()
	fake.ExtractDataStub = stub
}

func (fake *FakeBrowserAutomation) ExtractDataArgsForCall(i int) (context.Context, string, []map[string]any, string) {
	fake.extractDataMutex.RLock()
	defer fake.extractDataMutex.RUnlock()
	argsForCall := fake.extractDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeBrowserAutomation) ExtractDataReturns(result1 string, result2 error) {
	fake.extractDataMutex.Lock()
	defer fake.extractDataMutex.Unlock()
	fake.ExtractDataStub = nil
	fake.extractDataReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBrowserAutomation) ExtractDataReturnsOnCall(i int, result1 string, result2 error) {
	fake.extractDataMutex.Lock()
	defer fake.extractDataMutex.Unlock()
	fake.ExtractDataStub = nil
	if fake.extractDataReturnsOnCall == nil {
		fake.extractDataReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.extractDataReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeBrowserAutomation) FillForm(arg1 context.Context, arg2 string, arg3 []map[string]any, arg4 bool, arg5 string) error {
	var arg3Copy []map[string]any
	if arg3 != nil {
		arg3Copy = make([]map[string]any, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.fillFormMutex.Lock()
	ret, specificReturn := fake.fillFormReturnsOnCall[len(fake.fillFormArgsForCall)]
	fake.fillFormArgsForCall = append(fake.fillFormArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []map[string]any
		arg4 bool
		arg5 string
	}{arg1, arg2, arg3Copy, arg4, arg5})
	stub := fake.FillFormStub
	fakeReturns := fake.fillFormReturns
	fake.recordInvocation("FillForm", []any{arg1, arg2, arg3Copy, arg4, arg5})
	fake.fillFormMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBrowserAutomation) FillFormCallCount() int {
	fake.fillFormMutex.RLock()
	defer fake.fillFormMutex.RUnlock()
	return len(fake.fillFormArgsForCall)
}

func (fake *FakeBrowserAutomation) FillFormCalls(stub func(context.Context, string, []map[string]any, bool, string) error) {
	fake.fillFormMutex.Lock()
	defer fake.fillFormMutex.Unlock()
	fake.FillFormStub = stub
}

func (fake *FakeBrowserAutomation) FillFormArgsForCall(i int) (context.Context, string, []map[string]any, bool, string) {
	fake.fillFormMutex.RLock()
	defer fake.fillFormMutex.RUnlock()
	argsForCall := fake.fillFormArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeBrowserAutomation) FillFormReturns(result1 error) {
	fake.fillFormMutex.Lock()
	defer fake.fillFormMutex.Unlock()
	fake.FillFormStub = nil
	fake.fillFormReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) FillFormReturnsOnCall(i int, result1 error) {
	fake.fillFormMutex.Lock()
	defer fake.fillFormMutex.Unlock()
	fake.FillFormStub = nil
	if fake.fillFormReturnsOnCall == nil {
		fake.fillFormReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.fillFormReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) GetHealth(arg1 context.Context) error {
	fake.getHealthMutex.Lock()
	ret, specificReturn := fake.getHealthReturnsOnCall[len(fake.getHealthArgsForCall)]
	fake.getHealthArgsForCall = append(fake.getHealthArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetHealthStub
	fakeReturns := fake.getHealthReturns
	fake.recordInvocation("GetHealth", []any{arg1})
	fake.getHealthMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBrowserAutomation) GetHealthCallCount() int {
	fake.getHealthMutex.RLock()
	defer fake.getHealthMutex.RUnlock()
	return len(fake.getHealthArgsForCall)
}

func (fake *FakeBrowserAutomation) GetHealthCalls(stub func(context.Context) error) {
	fake.getHealthMutex.Lock()
	defer fake.getHealthMutex.Unlock()
	fake.GetHealthStub = stub
}

func (fake *FakeBrowserAutomation) GetHealthArgsForCall(i int) context.Context {
	fake.getHealthMutex.RLock()
	defer fake.getHealthMutex.RUnlock()
	argsForCall := fake.getHealthArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBrowserAutomation) GetHealthReturns(result1 error) {
	fake.getHealthMutex.Lock()
	defer fake.getHealthMutex.Unlock()
	fake.GetHealthStub = nil
	fake.getHealthReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) GetHealthReturnsOnCall(i int, result1 error) {
	fake.getHealthMutex.Lock()
	defer fake.getHealthMutex.Unlock()
	fake.GetHealthStub = nil
	if fake.getHealthReturnsOnCall == nil {
		fake.getHealthReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getHealthReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) GetSession(arg1 string) (*playwright.BrowserSession, error) {
	fake.getSessionMutex.Lock()
	ret, specificReturn := fake.getSessionReturnsOnCall[len(fake.getSessionArgsForCall)]
	fake.getSessionArgsForCall = append(fake.getSessionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetSessionStub
	fakeReturns := fake.getSessionReturns
	fake.recordInvocation("GetSession", []any{arg1})
	fake.getSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBrowserAutomation) GetSessionCallCount() int {
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	return len(fake.getSessionArgsForCall)
}

func (fake *FakeBrowserAutomation) GetSessionCalls(stub func(string) (*playwright.BrowserSession, error)) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = stub
}

func (fake *FakeBrowserAutomation) GetSessionArgsForCall(i int) string {
	fake.getSessionMutex.RLock()
	defer fake.getSessionMutex.RUnlock()
	argsForCall := fake.getSessionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBrowserAutomation) GetSessionReturns(result1 *playwright.BrowserSession, result2 error) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = nil
	fake.getSessionReturns = struct {
		result1 *playwright.BrowserSession
		result2 error
	}{result1, result2}
}

func (fake *FakeBrowserAutomation) GetSessionReturnsOnCall(i int, result1 *playwright.BrowserSession, result2 error) {
	fake.getSessionMutex.Lock()
	defer fake.getSessionMutex.Unlock()
	fake.GetSessionStub = nil
	if fake.getSessionReturnsOnCall == nil {
		fake.getSessionReturnsOnCall = make(map[int]struct {
			result1 *playwright.BrowserSession
			result2 error
		})
	}
	fake.getSessionReturnsOnCall[i] = struct {
		result1 *playwright.BrowserSession
		result2 error
	}{result1, result2}
}

func (fake *FakeBrowserAutomation) HandleAuthentication(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string, arg7 map[string]string) error {
	fake.handleAuthenticationMutex.Lock()
	ret, specificReturn := fake.handleAuthenticationReturnsOnCall[len(fake.handleAuthenticationArgsForCall)]
	fake.handleAuthenticationArgsForCall = append(fake.handleAuthenticationArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 map[string]string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.HandleAuthenticationStub
	fakeReturns := fake.handleAuthenticationReturns
	fake.recordInvocation("HandleAuthentication", []any{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.handleAuthenticationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBrowserAutomation) HandleAuthenticationCallCount() int {
	fake.handleAuthenticationMutex.RLock()
	defer fake.handleAuthenticationMutex.RUnlock()
	return len(fake.handleAuthenticationArgsForCall)
}

func (fake *FakeBrowserAutomation) HandleAuthenticationCalls(stub func(context.Context, string, string, string, string, string, map[string]string) error) {
	fake.handleAuthenticationMutex.Lock()
	defer fake.handleAuthenticationMutex.Unlock()
	fake.HandleAuthenticationStub = stub
}

func (fake *FakeBrowserAutomation) HandleAuthenticationArgsForCall(i int) (context.Context, string, string, string, string, string, map[string]string) {
	fake.handleAuthenticationMutex.RLock()
	defer fake.handleAuthenticationMutex.RUnlock()
	argsForCall := fake.handleAuthenticationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeBrowserAutomation) HandleAuthenticationReturns(result1 error) {
	fake.handleAuthenticationMutex.Lock()
	defer fake.handleAuthenticationMutex.Unlock()
	fake.HandleAuthenticationStub = nil
	fake.handleAuthenticationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) HandleAuthenticationReturnsOnCall(i int, result1 error) {
	fake.handleAuthenticationMutex.Lock()
	defer fake.handleAuthenticationMutex.Unlock()
	fake.HandleAuthenticationStub = nil
	if fake.handleAuthenticationReturnsOnCall == nil {
		fake.handleAuthenticationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.handleAuthenticationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) LaunchBrowser(arg1 context.Context, arg2 *playwright.BrowserConfig) (*playwright.BrowserSession, error) {
	fake.launchBrowserMutex.Lock()
	ret, specificReturn := fake.launchBrowserReturnsOnCall[len(fake.launchBrowserArgsForCall)]
	fake.launchBrowserArgsForCall = append(fake.launchBrowserArgsForCall, struct {
		arg1 context.Context
		arg2 *playwright.BrowserConfig
	}{arg1, arg2})
	stub := fake.LaunchBrowserStub
	fakeReturns := fake.launchBrowserReturns
	fake.recordInvocation("LaunchBrowser", []any{arg1, arg2})
	fake.launchBrowserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBrowserAutomation) LaunchBrowserCallCount() int {
	fake.launchBrowserMutex.RLock()
	defer fake.launchBrowserMutex.RUnlock()
	return len(fake.launchBrowserArgsForCall)
}

func (fake *FakeBrowserAutomation) LaunchBrowserCalls(stub func(context.Context, *playwright.BrowserConfig) (*playwright.BrowserSession, error)) {
	fake.launchBrowserMutex.Lock()
	defer fake.launchBrowserMutex.Unlock()
	fake.LaunchBrowserStub = stub
}

func (fake *FakeBrowserAutomation) LaunchBrowserArgsForCall(i int) (context.Context, *playwright.BrowserConfig) {
	fake.launchBrowserMutex.RLock()
	defer fake.launchBrowserMutex.RUnlock()
	argsForCall := fake.launchBrowserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeBrowserAutomation) LaunchBrowserReturns(result1 *playwright.BrowserSession, result2 error) {
	fake.launchBrowserMutex.Lock()
	defer fake.launchBrowserMutex.Unlock()
	fake.LaunchBrowserStub = nil
	fake.launchBrowserReturns = struct {
		result1 *playwright.BrowserSession
		result2 error
	}{result1, result2}
}

func (fake *FakeBrowserAutomation) LaunchBrowserReturnsOnCall(i int, result1 *playwright.BrowserSession, result2 error) {
	fake.launchBrowserMutex.Lock()
	defer fake.launchBrowserMutex.Unlock()
	fake.LaunchBrowserStub = nil
	if fake.launchBrowserReturnsOnCall == nil {
		fake.launchBrowserReturnsOnCall = make(map[int]struct {
			result1 *playwright.BrowserSession
			result2 error
		})
	}
	fake.launchBrowserReturnsOnCall[i] = struct {
		result1 *playwright.BrowserSession
		result2 error
	}{result1, result2}
}

func (fake *FakeBrowserAutomation) NavigateToURL(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 time.Duration) error {
	fake.navigateToURLMutex.Lock()
	ret, specificReturn := fake.navigateToURLReturnsOnCall[len(fake.navigateToURLArgsForCall)]
	fake.navigateToURLArgsForCall = append(fake.navigateToURLArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 time.Duration
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.NavigateToURLStub
	fakeReturns := fake.navigateToURLReturns
	fake.recordInvocation("NavigateToURL", []any{arg1, arg2, arg3, arg4, arg5})
	fake.navigateToURLMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBrowserAutomation) NavigateToURLCallCount() int {
	fake.navigateToURLMutex.RLock()
	defer fake.navigateToURLMutex.RUnlock()
	return len(fake.navigateToURLArgsForCall)
}

func (fake *FakeBrowserAutomation) NavigateToURLCalls(stub func(context.Context, string, string, string, time.Duration) error) {
	fake.navigateToURLMutex.Lock()
	defer fake.navigateToURLMutex.Unlock()
	fake.NavigateToURLStub = stub
}

func (fake *FakeBrowserAutomation) NavigateToURLArgsForCall(i int) (context.Context, string, string, string, time.Duration) {
	fake.navigateToURLMutex.RLock()
	defer fake.navigateToURLMutex.RUnlock()
	argsForCall := fake.navigateToURLArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeBrowserAutomation) NavigateToURLReturns(result1 error) {
	fake.navigateToURLMutex.Lock()
	defer fake.navigateToURLMutex.Unlock()
	fake.NavigateToURLStub = nil
	fake.navigateToURLReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) NavigateToURLReturnsOnCall(i int, result1 error) {
	fake.navigateToURLMutex.Lock()
	defer fake.navigateToURLMutex.Unlock()
	fake.NavigateToURLStub = nil
	if fake.navigateToURLReturnsOnCall == nil {
		fake.navigateToURLReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.navigateToURLReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) Shutdown(arg1 context.Context) error {
	fake.shutdownMutex.Lock()
	ret, specificReturn := fake.shutdownReturnsOnCall[len(fake.shutdownArgsForCall)]
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ShutdownStub
	fakeReturns := fake.shutdownReturns
	fake.recordInvocation("Shutdown", []any{arg1})
	fake.shutdownMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBrowserAutomation) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakeBrowserAutomation) ShutdownCalls(stub func(context.Context) error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = stub
}

func (fake *FakeBrowserAutomation) ShutdownArgsForCall(i int) context.Context {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	argsForCall := fake.shutdownArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeBrowserAutomation) ShutdownReturns(result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) ShutdownReturnsOnCall(i int, result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	if fake.shutdownReturnsOnCall == nil {
		fake.shutdownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.shutdownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) TakeScreenshot(arg1 context.Context, arg2 string, arg3 string, arg4 bool, arg5 string, arg6 string, arg7 int) error {
	fake.takeScreenshotMutex.Lock()
	ret, specificReturn := fake.takeScreenshotReturnsOnCall[len(fake.takeScreenshotArgsForCall)]
	fake.takeScreenshotArgsForCall = append(fake.takeScreenshotArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 bool
		arg5 string
		arg6 string
		arg7 int
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.TakeScreenshotStub
	fakeReturns := fake.takeScreenshotReturns
	fake.recordInvocation("TakeScreenshot", []any{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.takeScreenshotMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBrowserAutomation) TakeScreenshotCallCount() int {
	fake.takeScreenshotMutex.RLock()
	defer fake.takeScreenshotMutex.RUnlock()
	return len(fake.takeScreenshotArgsForCall)
}

func (fake *FakeBrowserAutomation) TakeScreenshotCalls(stub func(context.Context, string, string, bool, string, string, int) error) {
	fake.takeScreenshotMutex.Lock()
	defer fake.takeScreenshotMutex.Unlock()
	fake.TakeScreenshotStub = stub
}

func (fake *FakeBrowserAutomation) TakeScreenshotArgsForCall(i int) (context.Context, string, string, bool, string, string, int) {
	fake.takeScreenshotMutex.RLock()
	defer fake.takeScreenshotMutex.RUnlock()
	argsForCall := fake.takeScreenshotArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeBrowserAutomation) TakeScreenshotReturns(result1 error) {
	fake.takeScreenshotMutex.Lock()
	defer fake.takeScreenshotMutex.Unlock()
	fake.TakeScreenshotStub = nil
	fake.takeScreenshotReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) TakeScreenshotReturnsOnCall(i int, result1 error) {
	fake.takeScreenshotMutex.Lock()
	defer fake.takeScreenshotMutex.Unlock()
	fake.TakeScreenshotStub = nil
	if fake.takeScreenshotReturnsOnCall == nil {
		fake.takeScreenshotReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.takeScreenshotReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) WaitForCondition(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 time.Duration, arg7 string) error {
	fake.waitForConditionMutex.Lock()
	ret, specificReturn := fake.waitForConditionReturnsOnCall[len(fake.waitForConditionArgsForCall)]
	fake.waitForConditionArgsForCall = append(fake.waitForConditionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 time.Duration
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.WaitForConditionStub
	fakeReturns := fake.waitForConditionReturns
	fake.recordInvocation("WaitForCondition", []any{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.waitForConditionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeBrowserAutomation) WaitForConditionCallCount() int {
	fake.waitForConditionMutex.RLock()
	defer fake.waitForConditionMutex.RUnlock()
	return len(fake.waitForConditionArgsForCall)
}

func (fake *FakeBrowserAutomation) WaitForConditionCalls(stub func(context.Context, string, string, string, string, time.Duration, string) error) {
	fake.waitForConditionMutex.Lock()
	defer fake.waitForConditionMutex.Unlock()
	fake.WaitForConditionStub = stub
}

func (fake *FakeBrowserAutomation) WaitForConditionArgsForCall(i int) (context.Context, string, string, string, string, time.Duration, string) {
	fake.waitForConditionMutex.RLock()
	defer fake.waitForConditionMutex.RUnlock()
	argsForCall := fake.waitForConditionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeBrowserAutomation) WaitForConditionReturns(result1 error) {
	fake.waitForConditionMutex.Lock()
	defer fake.waitForConditionMutex.Unlock()
	fake.WaitForConditionStub = nil
	fake.waitForConditionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) WaitForConditionReturnsOnCall(i int, result1 error) {
	fake.waitForConditionMutex.Lock()
	defer fake.waitForConditionMutex.Unlock()
	fake.WaitForConditionStub = nil
	if fake.waitForConditionReturnsOnCall == nil {
		fake.waitForConditionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.waitForConditionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeBrowserAutomation) Invocations() map[string][][]any {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]any{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBrowserAutomation) recordInvocation(key string, args []any) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]any{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]any{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ playwright.BrowserAutomation = new(FakeBrowserAutomation)
